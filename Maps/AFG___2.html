<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js and the geo projection plugin -->
<script src="https://d3js.org/d3.v4.js"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
<style> 
  #rcorners1 {
    border-radius: 45px;
    background: #eaeee6;
    padding: 22px; 
    width: 220px;
    height: 25px;  
  }
</style>
<!-- Button -->
<table> 
  <tr>
    <td align="center">

    </td>
    <td>
      <div id="rcorners1">
        <input type="checkbox" class="checkbox" value="A" checked><label>2018</label>
        <input type="checkbox" class="checkbox" value="B" checked><label>2019</label>
        <input type="checkbox" class="checkbox" value="C" checked><label>2020</label>
        <input type="checkbox" class="checkbox" value="D" checked><label>2021</label>
      </div>
    </td>
  </tr>
</table>


<!-- Create an element where the map will take place -->
<svg id="my_dataviz" width="540" height="500"></svg>

<script>
  // The svg
  var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height");
  
  // Map and projection
  var projection = d3.geoMercator()
    .center([69, 31])                // GPS of location to zoom on3
    .scale(1500)                       // This is like the zoom
    .translate([ width/2, height/2 ]);
  
  // Create data for circles:
  var request = new XMLHttpRequest();
  request.open("GET", "./assets/AFG1.json", false);
  request.send(null)
  var markers = JSON.parse(request.responseText);

  d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson", function(data){
  
      // Filter data
      data.features = data.features.filter( function(d){return d.properties.name=="Afghanistan"} )
  
      // Create a color scale
      var color = d3.scaleOrdinal()
        .domain(["A", "B", "C", "D" ])
        .range([ "#402D54", "#D18975", "#8FD175", "#FFF111"])
  
      // Add a scale for bubble size
      var size = d3.scaleLinear()
        .domain([1,50])  // What's in the data
        .range([ 3, 50])  // Size in pixel
  
      // Draw the map
      svg.append("g")
          .selectAll("path")
          .data(data.features)
          .enter()
          .append("path")
            .attr("fill", "#b8b8b8")
            .attr("d", d3.geoPath()
                .projection(projection)
            )
          .style("stroke", "black")
          .style("opacity", .3)
  
      // Add circles:
      svg
        .selectAll("myCircles")
        .data(markers)
        .enter()
        .append("circle")
          .attr("class" , function(d){ return d.group })
          .attr("cx", function(d){ return projection([d.long, d.lat])[0] })
          .attr("cy", function(d){ return projection([d.long, d.lat])[1] })
          .attr("r", function(d){ return size(d.size) })
          .style("fill", function(d){ return color(d.group) })
          .attr("stroke", function(d){ return color(d.group) })
          .attr("stroke-width", 3)
          .attr("fill-opacity", .4)

      // This function is gonna change the opacity and size of selected and unselected circles
      function update(){
        // For each check box:
        d3.selectAll(".checkbox").each(function(d){
          cb = d3.select(this);
          grp = cb.property("value")
  
          // If the box is check, I show the group
          if(cb.property("checked")){
            svg.selectAll("."+grp).transition().duration(1000).style("opacity", 1).attr("r", function(d){ return size(d.size) })
          // Otherwise I hide it
          }else{
            svg.selectAll("."+grp).transition().duration(1000).style("opacity", 0).attr("r", 0)
          }
        })
      }
      // When a button change, I run the update function
      d3.selectAll(".checkbox").on("change",update);
      // And I initialize it at the beginning
      update()
  })
</script>